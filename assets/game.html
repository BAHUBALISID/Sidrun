<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sid & Tushi Mario Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(to bottom, #6ab7ff, #1e88e5);
            color: white;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 90vh;
            max-height: 700px;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            background: #f0f0f0;
        }
        
        .game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #87ceeb 0%, #64b5f6 100%);
            z-index: 1;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }
        
        .score-display, .lives-display, .distance-display {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .ui-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 12px;
            right: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            z-index: 10;
        }
        
        .btn {
            background-color: rgba(255, 255, 255, 0.9);
            border: none;
            color: #333;
            font-size: 24px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 16px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s, background-color 0.2s;
            padding: 0;
            z-index: 11;
        }
        
        .btn:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 1);
        }
        
        .wide {
            width: 70px;
            height: 60px;
        }
        
        .jump {
            width: 90px;
            height: 60px;
        }
        
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            max-width: 320px;
            z-index: 20;
            backdrop-filter: blur(10px);
            border: 2px solid #ffcc00;
        }
        
        .instructions h2 {
            margin-bottom: 15px;
            color: #ffcc00;
            font-size: 28px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .instructions p {
            margin-bottom: 15px;
            line-height: 1.5;
            font-size: 16px;
        }
        
        .start-btn {
            background: linear-gradient(to bottom, #4caf50, #388e3c);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            z-index: 20;
            width: 80%;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 2px solid #ff4d4f;
        }
        
        .game-over h2 {
            color: #ff4d4f;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        .game-over p {
            margin-bottom: 20px;
            font-size: 18px;
        }
        
        .restart-btn {
            background: linear-gradient(to bottom, #ff4d4f, #d32f2f);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .character-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            backdrop-filter: blur(5px);
            z-index: 10;
        }
        
        .character-switch select {
            background: transparent;
            border: none;
            color: white;
            font-weight: bold;
            outline: none;
        }
        
        .thought-bubble {
            position: absolute;
            background: white;
            border-radius: 20px;
            padding: 10px 15px;
            color: #333;
            font-weight: bold;
            display: none;
            z-index: 15;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 120px;
        }
        
        .thought-bubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: white transparent transparent;
        }
        
        .kiss-effect {
            position: absolute;
            display: none;
            font-size: 40px;
            z-index: 15;
            animation: floatUp 2s ease-out;
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100px); opacity: 0; }
        }
        
        /* React Native-like components */
        .rn-view {
            display: flex;
        }
        
        .rn-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        /* Responsive adjustments */
        @media (max-height: 700px) {
            .container {
                height: 95vh;
            }
            
            .controls {
                bottom: 10px;
            }
            
            .btn {
                width: 60px;
                height: 50px;
                font-size: 20px;
            }
            
            .jump {
                width: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas class="game-canvas" id="game-canvas"></canvas>
        
        <div class="game-ui">
            <div class="ui-container">
                <div class="score-display">
                    <span>‚≠ê</span>
                    <span id="score">0</span>
                </div>
                <div class="distance-display">
                    <span>üìè</span>
                    <span id="distance">0m</span>
                </div>
            </div>
            <div class="lives-display">
                <span>‚ù§Ô∏è</span>
                <span id="lives">3</span>
            </div>
        </div>
        
        <div class="character-switch">
            <select id="character-select">
                <option value="sid">Sid</option>
                <option value="tushi">Tushi</option>
            </select>
        </div>
        
        <div class="thought-bubble" id="thought-bubble">I'm coming for uhh tushi<br>Miss you!</div>
        <div class="kiss-effect" id="kiss-effect">üíã</div>
        
        <div class="controls">
            <button class="btn wide" id="left-btn">‚óÄ</button>
            <button class="btn wide" id="right-btn">‚ñ∂</button>
            <button class="btn jump" id="jump-btn">‚§í</button>
        </div>
        
        <div class="instructions" id="instructions">
            <h2>Sid & Tushi Adventure</h2>
            <p>Run endlessly, avoid enemies, collect coins and power-ups!</p>
            <p>Switch between Sid and Tushi characters!</p>
            <p>Made with üíñby sid</p>
            <button class="start-btn" id="start-btn">Start Game</button>
        </div>
        
        <div class="game-over" id="game-over">
            <h2>Game Over</h2>
            <p>Score: <span id="final-score">0</span></p>
            <p>Distance: <span id="final-distance">0m</span></p>
            <button class="restart-btn" id="restart-btn">Play Again</button>
        </div>
    </div>

    <script>
        // Game constants and state
        const gameWidth = 500;
        const gameHeight = 600;
        const playerWidth = 35;
        const playerHeight = 45;
        const gravity = 0.5;
        const jumpStrength = 12;
        const moveSpeed = 5;
        const initialScrollSpeed = 2;
        const bossDistance = 1000; // Distance at which boss appears
        
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let distance = 0;
        let playerX = 100;
        let playerY = 400;
        let velocityX = 0;
        let velocityY = 0;
        let isJumping = false;
        let leftKeyActive = false;
        let rightKeyActive = false;
        let scrollSpeed = initialScrollSpeed;
        let difficultyLevel = 1;
        let bossActive = false;
        let bossHealth = 100;
        let powerupActive = false;
        let powerupTimer = 0;
        let powerupType = '';
        let currentCharacter = 'sid';
        let lastTushiAppearance = 0;
        let phoneOrientation = null;
        let tushiActive = false;
        let tushiTimer = 0;
        let tushiX = 0;
        let tushiY = 400;
        let tushiState = 'waiting'; // waiting, approaching, kissing, leaving
        
        // Game elements
        let platforms = [];
        let enemies = [];
        let coins = [];
        let pipes = [];
        let powerups = [];
        let boss = null;
        let projectiles = [];
        let cloudPlatforms = [];
        
        // DOM Elements
        const gameContainer = document.querySelector('.container');
        const gameCanvas = document.getElementById('game-canvas');
        const ctx = gameCanvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const distanceDisplay = document.getElementById('distance');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalDistanceDisplay = document.getElementById('final-distance');
        const instructions = document.getElementById('instructions');
        const gameOver = document.getElementById('game-over');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const jumpBtn = document.getElementById('jump-btn');
        const characterSelect = document.getElementById('character-select');
        const thoughtBubble = document.getElementById('thought-bubble');
        const kissEffect = document.getElementById('kiss-effect');
        
        // Set canvas size
        gameCanvas.width = gameWidth;
        gameCanvas.height = gameHeight;
        
        // Initialize the game
        function init() {
            // Reset game state
            score = 0;
            lives = 3;
            distance = 0;
            playerX = 100;
            playerY = 400;
            velocityX = 0;
            velocityY = 0;
            isJumping = false;
            scrollSpeed = initialScrollSpeed;
            difficultyLevel = 1;
            bossActive = false;
            bossHealth = 100;
            powerupActive = false;
            powerupTimer = 0;
            lastTushiAppearance = 0;
            tushiActive = false;
            tushiTimer = 0;
            tushiState = 'waiting';
            
            // Update displays
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            distanceDisplay.textContent = distance + 'm';
            
            // Clear all game elements
            platforms = [];
            enemies = [];
            coins = [];
            pipes = [];
            powerups = [];
            boss = null;
            projectiles = [];
            cloudPlatforms = [];
            
            // Create initial platforms
            createInitialPlatforms();
            
            // Start game loop
            gameRunning = true;
            gameLoop();
        }
        
        // Create initial platforms
        function createInitialPlatforms() {
            // Ground platform
            platforms.push({x: 0, y: 550, width: gameWidth, height: 50, type: 'ground'});
            
            // Add some initial platforms
            for (let i = 0; i < 5; i++) {
                const platformWidth = 80 + Math.random() * 70;
                const platformX = 200 + i * 200 + Math.random() * 100;
                const platformY = 450 - Math.random() * 100;
                const isCloud = Math.random() > 0.7;
                
                platforms.push({
                    x: platformX,
                    y: platformY,
                    width: platformWidth,
                    height: 20,
                    type: isCloud ? 'cloud' : 'ground'
                });
                
                // Sometimes add enemies on platforms (not on clouds)
                if (Math.random() > 0.5 && !isCloud) {
                    enemies.push({
                        x: platformX + platformWidth/2,
                        y: platformY - 30,
                        width: 30,
                        height: 30,
                        speed: 1 + Math.random(),
                        direction: Math.random() > 0.5 ? 1 : -1
                    });
                }
                
                // Sometimes add coins on platforms
                if (Math.random() > 0.3) {
                    coins.push({
                        x: platformX + Math.random() * (platformWidth - 20),
                        y: platformY - 30,
                        width: 20,
                        height: 20,
                        collected: false
                    });
                }
            }
            
            // Add some cloud platforms in the sky
            for (let i = 0; i < 3; i++) {
                const cloudWidth = 100 + Math.random() * 50;
                const cloudX = 300 + i * 300 + Math.random() * 200;
                const cloudY = 200 + Math.random() * 100;
                
                cloudPlatforms.push({
                    x: cloudX,
                    y: cloudY,
                    width: cloudWidth,
                    height: 30,
                    type: 'cloud'
                });
                
                // Add coins on cloud platforms
                if (Math.random() > 0.5) {
                    coins.push({
                        x: cloudX + Math.random() * (cloudWidth - 20),
                        y: cloudY - 30,
                        width: 20,
                        height: 20,
                        collected: false
                    });
                }
            }
        }
        
        // Generate new platforms as the player progresses
        function generateNewPlatforms() {
            // Find the rightmost platform
            let rightmostPlatform = 0;
            platforms.forEach(p => {
                if (p.x + p.width > rightmostPlatform) rightmostPlatform = p.x + p.width;
            });
            
            // Generate new platforms if we're getting close to the end
            if (rightmostPlatform - distance < gameWidth * 2) {
                const platformWidth = 80 + Math.random() * 70;
                const platformX = rightmostPlatform + 100 + Math.random() * 150;
                const platformY = 450 - Math.random() * 150;
                const isCloud = Math.random() > 0.7;
                
                // Ensure platforms don't go too high or too low
                const minY = isCloud ? 150 : 300;
                const maxY = isCloud ? 350 : 500;
                const clampedY = Math.max(minY, Math.min(maxY, platformY));
                
                platforms.push({
                    x: platformX,
                    y: clampedY,
                    width: platformWidth,
                    height: 20,
                    type: isCloud ? 'cloud' : 'ground'
                });
                
                // Sometimes add enemies on platforms (not on clouds)
                if (Math.random() > 0.6 - (difficultyLevel * 0.1) && !isCloud) {
                    enemies.push({
                        x: platformX + platformWidth/2,
                        y: clampedY - 30,
                        width: 30,
                        height: 30,
                        speed: 1 + Math.random() + (difficultyLevel * 0.2),
                        direction: Math.random() > 0.5 ? 1 : -1
                    });
                }
                
                // Sometimes add coins on platforms
                if (Math.random() > 0.2) {
                    coins.push({
                        x: platformX + Math.random() * (platformWidth - 20),
                        y: clampedY - 30,
                        width: 20,
                        height: 20,
                        collected: false
                    });
                }
                
                // Occasionally add power-ups (rarer)
                if (Math.random() > 0.9) {
                    powerups.push({
                        x: platformX + Math.random() * (platformWidth - 20),
                        y: clampedY - 40,
                        width: 25,
                        height: 25,
                        type: Math.random() > 0.5 ? 'fire' : 'invincible',
                        collected: false
                    });
                }
            }
            
            // Generate new cloud platforms
            let rightmostCloud = 0;
            cloudPlatforms.forEach(p => {
                if (p.x + p.width > rightmostCloud) rightmostCloud = p.x + p.width;
            });
            
            if (rightmostCloud - distance < gameWidth * 2) {
                const cloudWidth = 100 + Math.random() * 50;
                const cloudX = rightmostCloud + 200 + Math.random() * 200;
                const cloudY = 150 + Math.random() * 150;
                
                cloudPlatforms.push({
                    x: cloudX,
                    y: cloudY,
                    width: cloudWidth,
                    height: 30,
                    type: 'cloud'
                });
                
                // Add coins on cloud platforms
                if (Math.random() > 0.5) {
                    coins.push({
                        x: cloudX + Math.random() * (cloudWidth - 20),
                        y: cloudY - 30,
                        width: 20,
                        height: 20,
                        collected: false
                    });
                }
            }
        }
        
        // Show Tushi every 200m
        function showTushi() {
            if (distance - lastTushiAppearance >= 200 && !tushiActive && currentCharacter === 'sid') {
                lastTushiAppearance = distance;
                tushiActive = true;
                tushiState = 'approaching';
                tushiTimer = 240; // 4 seconds at 60fps
                tushiX = distance + gameWidth + 50;
                tushiY = 400;
                
                // Show thought bubble
                thoughtBubble.style.display = 'block';
                thoughtBubble.style.left = (playerX - 40) + 'px';
                thoughtBubble.style.top = (playerY - 60) + 'px';
            }
        }
        
        // Update Tushi appearance
        function updateTushi() {
            if (!tushiActive) return;
            
            tushiTimer--;
            
            if (tushiState === 'approaching') {
                tushiX -= scrollSpeed + 3; // Move faster than scroll speed
                
                // If Tushi is close to Sid, switch to kissing state
                if (tushiX - distance < playerX + 100) {
                    tushiState = 'kissing';
                    tushiTimer = 120; // 2 seconds for kissing
                    
                    // Show kiss effect
                    kissEffect.style.display = 'block';
                    kissEffect.style.left = (playerX + playerWidth/2 - 20) + 'px';
                    kissEffect.style.top = (playerY - 40) + 'px';
                    
                    // Hide after animation
                    setTimeout(() => {
                        kissEffect.style.display = 'none';
                    }, 2000);
                    
                    // Give player a bonus
                    score += 500;
                    scoreDisplay.textContent = score;
                }
            } 
            else if (tushiState === 'kissing') {
                // Keep Tushi next to Sid
                tushiX = distance + playerX + 30;
                
                // After kissing time, switch to leaving state
                if (tushiTimer < 60) {
                    tushiState = 'leaving';
                }
            }
            else if (tushiState === 'leaving') {
                // Move Tushi away
                tushiX += 6;
            }
            
            // Draw Tushi in all states except waiting
            drawTushiCharacter(tushiX - distance, tushiY);
            
            // Update thought bubble position to follow player
            thoughtBubble.style.left = (playerX - 40) + 'px';
            thoughtBubble.style.top = (playerY - 60) + 'px';
            
            if (tushiTimer <= 0 || tushiX - distance > gameWidth + 100) {
                tushiActive = false;
                thoughtBubble.style.display = 'none';
            }
        }
        
        // Draw Tushi character
        function drawTushiCharacter(x, y) {
            // Tushi body (pink dress)
            ctx.fillStyle = '#e91e63';
            ctx.fillRect(x, y, playerWidth, playerHeight);
            
            // Dress details
            ctx.fillStyle = '#ad1457';
            ctx.fillRect(x, y + playerHeight - 15, playerWidth, 5);
            ctx.fillRect(x + 10, y + 10, 5, playerHeight - 25);
            ctx.fillRect(x + playerWidth - 15, y + 10, 5, playerHeight - 25);
            
            // Tushi face
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(x + playerWidth/2, y + 15, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Tushi hair
            ctx.fillStyle = '#8d6e63';
            ctx.beginPath();
            ctx.arc(x + playerWidth/2, y + 5, 15, 0, Math.PI, true);
            ctx.fill();
            
            // Tushi eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + playerWidth/2 - 5, y + 12, 3, 0, Math.PI * 2);
            ctx.arc(x + playerWidth/2 + 5, y + 12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + playerWidth/2 - 5, y + 12, 1.5, 0, Math.PI * 2);
            ctx.arc(x + playerWidth/2 + 5, y + 12, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Tushi mouth (smiling)
            ctx.fillStyle = '#e91e63';
            ctx.beginPath();
            ctx.arc(x + playerWidth/2, y + 20, 4, 0, Math.PI, false);
            ctx.fill();
            
            // Heart above head
            ctx.fillStyle = '#ff4d4d';
            ctx.beginPath();
            ctx.moveTo(x + playerWidth/2, y - 15);
            ctx.bezierCurveTo(
                x + playerWidth/2 + 10, y - 25,
                x + playerWidth/2 + 20, y - 15,
                x + playerWidth/2, y - 5
            );
            ctx.bezierCurveTo(
                x + playerWidth/2 - 20, y - 15,
                x + playerWidth/2 - 10, y - 25,
                x + playerWidth/2, y - 15
            );
            ctx.fill();
        }
        
        // Generate boss when distance is reached
        function generateBoss() {
            bossActive = true;
            
            boss = {
                x: distance + gameWidth + 100,
                y: 400,
                width: 80,
                height: 80,
                speed: 2,
                direction: -1,
                attackCooldown: 0,
                health: 100
            };
        }
        
        // Update boss behavior
        function updateBoss() {
            if (!boss) return;
            
            // Move boss
            boss.x += boss.speed * boss.direction;
            
            // Change direction if at edges
            if (boss.x < distance + 100 || boss.x > distance + gameWidth - 100) {
                boss.direction *= -1;
            }
            
            // Attack with projectiles
            boss.attackCooldown--;
            if (boss.attackCooldown <= 0) {
                projectiles.push({
                    x: boss.x,
                    y: boss.y + boss.height/2,
                    width: 20,
                    height: 20,
                    speed: 5,
                    direction: -1
                });
                
                boss.attackCooldown = 60 - (difficultyLevel * 5); // Faster attacks at higher difficulty
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                projectiles[i].x += projectiles[i].speed * projectiles[i].direction;
                
                // Remove projectiles that are off-screen
                if (projectiles[i].x < distance - 100) {
                    projectiles.splice(i, 1);
                }
            }
            
            // Check if player hits boss with fireball (if powerup is active)
            if (powerupActive && powerupType === 'fire') {
                if (
                    playerX + playerWidth > boss.x - distance &&
                    playerX < boss.x - distance + boss.width &&
                    playerY + playerHeight > boss.y &&
                    playerY < boss.y + boss.height
                ) {
                    boss.health -= 10;
                    
                    if (boss.health <= 0) {
                        // Boss defeated
                        score += 1000;
                        bossActive = false;
                        boss = null;
                        scoreDisplay.textContent = score;
                    }
                }
            }
        }
        
        // Game loop
        function gameLoop() {
            if (!gameRunning) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            
            // Update distance and difficulty
            distance += scrollSpeed / 10;
            distanceDisplay.textContent = Math.floor(distance) + 'm';
            
            // Increase difficulty every 200m
            difficultyLevel = Math.floor(distance / 200) + 1;
            scrollSpeed = initialScrollSpeed + (difficultyLevel * 0.3);
            
            // Show Tushi every 200m
            showTushi();
            
            // Update Tushi if active
            if (tushiActive) {
                updateTushi();
            }
            
            // Check if we should generate boss
            if (distance >= bossDistance && !bossActive && !boss) {
                generateBoss();
            }
            
            // Draw background
            drawBackground();
            
            // Generate new platforms if needed
            generateNewPlatforms();
            
            // Update and draw platforms
            for (let i = platforms.length - 1; i >= 0; i--) {
                platforms[i].x -= scrollSpeed;
                
                // Remove platforms that are off-screen
                if (platforms[i].x + platforms[i].width < distance - 100) {
                    platforms.splice(i, 1);
                    continue;
                }
                
                if (platforms[i].type === 'cloud') {
                    drawCloudPlatform(platforms[i]);
                } else {
                    drawPlatform(platforms[i]);
                }
            }
            
            // Update and draw cloud platforms
            for (let i = cloudPlatforms.length - 1; i >= 0; i--) {
                cloudPlatforms[i].x -= scrollSpeed;
                
                // Remove cloud platforms that are off-screen
                if (cloudPlatforms[i].x + cloudPlatforms[i].width < distance - 100) {
                    cloudPlatforms.splice(i, 1);
                    continue;
                }
                
                drawCloudPlatform(cloudPlatforms[i]);
            }
            
            // Update and draw pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                pipes[i].x -= scrollSpeed;
                
                // Remove pipes that are off-screen
                if (pipes[i].x + pipes[i].width < distance - 100) {
                    pipes.splice(i, 1);
                    continue;
                }
                
                drawPipe(pipes[i]);
            }
            
            // Update and draw coins
            for (let i = coins.length - 1; i >= 0; i--) {
                coins[i].x -= scrollSpeed;
                
                // Remove coins that are off-screen
                if (coins[i].x + coins[i].width < distance - 100) {
                    coins.splice(i, 1);
                    continue;
                }
                
                if (!coins[i].collected) {
                    drawCoin(coins[i]);
                    checkCoinCollision(coins[i]);
                }
            }
            
            // Update and draw powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                powerups[i].x -= scrollSpeed;
                
                // Remove powerups that are off-screen
                if (powerups[i].x + powerups[i].width < distance - 100) {
                    powerups.splice(i, 1);
                    continue;
                }
                
                if (!powerups[i].collected) {
                    drawPowerup(powerups[i]);
                    checkPowerupCollision(powerups[i]);
                }
            }
            
            // Update and draw enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].x -= scrollSpeed;
                
                // Remove enemies that are off-screen
                if (enemies[i].x + enemies[i].width < distance - 100) {
                    enemies.splice(i, 1);
                    continue;
                }
                
                updateEnemy(enemies[i]);
                drawEnemy(enemies[i]);
                checkEnemyCollision(enemies[i]);
            }
            
            // Update and draw boss
            if (bossActive && boss) {
                updateBoss();
                drawBoss();
                
                // Check projectile collisions with player
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    drawProjectile(projectiles[i]);
                    
                    if (
                        playerX + playerWidth > projectiles[i].x - distance &&
                        playerX < projectiles[i].x - distance + projectiles[i].width &&
                        playerY + playerHeight > projectiles[i].y &&
                        playerY < projectiles[i].y + projectiles[i].height
                    ) {
                        // Hit by projectile
                        projectiles.splice(i, 1);
                        if (!powerupActive || powerupType !== 'invincible') {
                            loseLife();
                        }
                    }
                }
            }
            
            // Update player position
            updatePlayer();
            
            // Draw player
            drawPlayer();
            
            // Update powerup timer
            if (powerupActive) {
                powerupTimer--;
                
                if (powerupTimer <= 0) {
                    powerupActive = false;
                }
            }
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Draw background
        function drawBackground() {
            // Draw sky
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // Draw distant hills
            ctx.fillStyle = '#81c784';
            drawHill(100 - (distance * 0.1) % gameWidth, 500, 80, 50);
            drawHill(300 - (distance * 0.2) % gameWidth, 500, 100, 60);
            drawHill(450 - (distance * 0.15) % gameWidth, 500, 70, 40);
            
            // Draw clouds in background
            for (let i = 0; i < 5; i++) {
                const cloudX = (i * 200 + distance * 0.05) % (gameWidth + 200) - 100;
                const cloudY = 100 + (i * 30) % 150;
                drawBackgroundCloud(cloudX, cloudY, 80 + (i * 10) % 40);
            }
        }
        
        function drawHill(x, y, width, height) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x + width/2, y - height, x + width, y);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawBackgroundCloud(x, y, size) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(x, y, size/2, 0, Math.PI * 2);
            ctx.arc(x + size/2, y - size/4, size/2.5, 0, Math.PI * 2);
            ctx.arc(x + size, y, size/2, 0, Math.PI * 2);
            ctx.arc(x + size/2, y + size/4, size/2.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw platform
        function drawPlatform(platform) {
            ctx.fillStyle = '#d35400';
            ctx.fillRect(platform.x - distance, platform.y, platform.width, platform.height);
            
            // Platform top
            ctx.fillStyle = '#e67e22';
            ctx.fillRect(platform.x - distance, platform.y, platform.width, 5);
            
            // Platform pattern
            ctx.fillStyle = '#ba4a00';
            for (let i = platform.x + 10; i < platform.x + platform.width; i += 15) {
                ctx.fillRect(i - distance, platform.y + 8, 5, 5);
            }
        }
        
        // Draw cloud platform
        function drawCloudPlatform(platform) {
            const x = platform.x - distance;
            const y = platform.y;
            const width = platform.width;
            const height = platform.height;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            
            // Draw cloud-like platform with multiple circles
            ctx.beginPath();
            ctx.arc(x + width/2, y + height/2, height/2, 0, Math.PI * 2);
            ctx.arc(x + width/4, y + height/2, height/1.5, 0, Math.PI * 2);
            ctx.arc(x + 3*width/4, y + height/2, height/1.5, 0, Math.PI * 2);
            ctx.arc(x + width/6, y + height/2, height/2, 0, Math.PI * 2);
            ctx.arc(x + 5*width/6, y + height/2, height/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Add some subtle shadow
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.beginPath();
            ctx.arc(x + width/2, y + height/2 + 2, height/2, 0, Math.PI * 2);
            ctx.arc(x + width/4, y + height/2 + 2, height/1.5, 0, Math.PI * 2);
            ctx.arc(x + 3*width/4, y + height/2 + 2, height/1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw pipe
        function drawPipe(pipe) {
            // Pipe body
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(pipe.x - distance, pipe.y, pipe.width, pipe.height);
            
            // Pipe top
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(pipe.x - distance - 5, pipe.y, pipe.width + 10, 15);
            
            // Pipe highlights
            ctx.fillStyle = '#58d68d';
            ctx.fillRect(pipe.x - distance + 5, pipe.y + 5, 5, pipe.height - 5);
        }
        
        // Draw coin
        function drawCoin(coin) {
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(coin.x - distance + coin.width/2, coin.y + coin.height/2, coin.width/2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(coin.x - distance + coin.width/2, coin.y + coin.height/2, coin.width/4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw powerup
        function drawPowerup(powerup) {
            if (powerup.type === 'fire') {
                ctx.fillStyle = '#ff4d4d';
                ctx.beginPath();
                ctx.arc(powerup.x - distance + powerup.width/2, powerup.y + powerup.height/2, powerup.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ff9999';
                ctx.beginPath();
                ctx.arc(powerup.x - distance + powerup.width/2, powerup.y + powerup.height/2, powerup.width/4, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = '#4d94ff';
                ctx.beginPath();
                ctx.arc(powerup.x - distance + powerup.width/2, powerup.y + powerup.height/2, powerup.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#99bbff';
                ctx.beginPath();
                ctx.arc(powerup.x - distance + powerup.width/2, powerup.y + powerup.height/2, powerup.width/4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw enemy
        function drawEnemy(enemy) {
            // Enemy body
            ctx.fillStyle = '#8e44ad';
            ctx.beginPath();
            ctx.arc(enemy.x - distance + enemy.width/2, enemy.y + enemy.height/2, enemy.width/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Enemy eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(enemy.x - distance + enemy.width/3, enemy.y + enemy.height/3, enemy.width/8, 0, Math.PI * 2);
            ctx.arc(enemy.x - distance + 2*enemy.width/3, enemy.y + enemy.height/3, enemy.width/8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(enemy.x - distance + enemy.width/3, enemy.y + enemy.height/3, enemy.width/16, 0, Math.PI * 2);
            ctx.arc(enemy.x - distance + 2*enemy.width/3, enemy.y + enemy.height/3, enemy.width/16, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw boss
        function drawBoss() {
            if (!boss) return;
            
            // Boss body
            ctx.fillStyle = '#d32f2f';
            ctx.fillRect(boss.x - distance, boss.y, boss.width, boss.height);
            
            // Boss details
            ctx.fillStyle = '#9a0007';
            ctx.fillRect(boss.x - distance, boss.y, boss.width, 15);
            
            // Boss eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(boss.x - distance + boss.width/3, boss.y + boss.height/3, boss.width/8, 0, Math.PI * 2);
            ctx.arc(boss.x - distance + 2*boss.width/3, boss.y + boss.height/3, boss.width/8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(boss.x - distance + boss.width/3, boss.y + boss.height/3, boss.width/16, 0, Math.PI * 2);
            ctx.arc(boss.x - distance + 2*boss.width/3, boss.y + boss.height/3, boss.width/16, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss mouth
            ctx.fillStyle = 'black';
            ctx.fillRect(boss.x - distance + boss.width/4, boss.y + 2*boss.height/3, boss.width/2, 5);
        }
        
        // Draw projectile
        function drawProjectile(projectile) {
            ctx.fillStyle = '#ff4d4d';
            ctx.beginPath();
            ctx.arc(projectile.x - distance + projectile.width/2, projectile.y + projectile.height/2, projectile.width/2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw player
        function drawPlayer() {
            if (currentCharacter === 'sid') {
                drawSid();
            } else {
                drawTushi();
            }
        }
        
        // Draw Sid character
        function drawSid() {
            // Player body (red overalls)
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
            
            // If player has invincibility powerup, add a glow effect
            if (powerupActive && powerupType === 'invincible') {
                ctx.strokeStyle = '#4d94ff';
                ctx.lineWidth = 3;
                ctx.strokeRect(playerX - 2, playerY - 2, playerWidth + 4, playerHeight + 4);
            }
            
            // If player has fire powerup, add fire effect
            if (powerupActive && powerupType === 'fire') {
                ctx.fillStyle = '#ff4d4d';
                ctx.beginPath();
                ctx.moveTo(playerX + playerWidth/2, playerY + playerHeight + 5);
                ctx.lineTo(playerX + playerWidth/2 - 10, playerY + playerHeight + 15);
                ctx.lineTo(playerX + playerWidth/2 + 10, playerY + playerHeight + 15);
                ctx.closePath();
                ctx.fill();
            }
            
            // Player face
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2, playerY + 15, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Player hat
            ctx.fillStyle = '#c0392b';
            ctx.fillRect(playerX + 5, playerY, playerWidth - 10, 10);
            
            // Player eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2 - 5, playerY + 12, 3, 0, Math.PI * 2);
            ctx.arc(playerX + playerWidth/2 + 5, playerY + 12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2 - 5, playerY + 12, 1.5, 0, Math.PI * 2);
            ctx.arc(playerX + playerWidth/2 + 5, playerY + 12, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw Tushi character
        function drawTushi() {
            // Player body (pink dress)
            ctx.fillStyle = '#e91e63';
            ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
            
            // Dress details
            ctx.fillStyle = '#ad1457';
            ctx.fillRect(playerX, playerY + playerHeight - 15, playerWidth, 5);
            ctx.fillRect(playerX + 10, playerY + 10, 5, playerHeight - 25);
            ctx.fillRect(playerX + playerWidth - 15, playerY + 10, 5, playerHeight - 25);
            
            // If player has invincibility powerup, add a glow effect
            if (powerupActive && powerupType === 'invincible') {
                ctx.strokeStyle = '#4d94ff';
                ctx.lineWidth = 3;
                ctx.strokeRect(playerX - 2, playerY - 2, playerWidth + 4, playerHeight + 4);
            }
            
            // If player has fire powerup, add fire effect
            if (powerupActive && powerupType === 'fire') {
                ctx.fillStyle = '#ff4d4d';
                ctx.beginPath();
                ctx.moveTo(playerX + playerWidth/2, playerY + playerHeight + 5);
                ctx.lineTo(playerX + playerWidth/2 - 10, playerY + playerHeight + 15);
                ctx.lineTo(playerX + playerWidth/2 + 10, playerY + playerHeight + 15);
                ctx.closePath();
                ctx.fill();
            }
            
            // Player face
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2, playerY + 15, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Player hair
            ctx.fillStyle = '#8d6e63';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2, playerY + 5, 15, 0, Math.PI, true);
            ctx.fill();
            
            // Player eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2 - 5, playerY + 12, 3, 0, Math.PI * 2);
            ctx.arc(playerX + playerWidth/2 + 5, playerY + 12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2 - 5, playerY + 12, 1.5, 0, Math.PI * 2);
            ctx.arc(playerX + playerWidth/2 + 5, playerY + 12, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Player mouth
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(playerX + playerWidth/2, playerY + 20, 3, 0, Math.PI, false);
            ctx.stroke();
        }
        
        // Update player position
        function updatePlayer() {
            // Apply horizontal movement based on keys or device orientation
            if (leftKeyActive || (phoneOrientation === 'left' && window.orientation !== undefined)) {
                velocityX = -moveSpeed;
            } else if (rightKeyActive || (phoneOrientation === 'right' && window.orientation !== undefined)) {
                velocityX = moveSpeed;
            } else {
                velocityX = 0;
            }
            
            // Apply gravity
            velocityY += gravity;
            
            // Update position
            playerX += velocityX;
            playerY += velocityY;
            
            // Check platform collisions
            let onPlatform = false;
            platforms.forEach(platform => {
                if (
                    playerX + playerWidth > platform.x - distance &&
                    playerX < platform.x - distance + platform.width &&
                    playerY + playerHeight > platform.y &&
                    playerY + playerHeight < platform.y + platform.height / 2 &&
                    velocityY > 0
                ) {
                    playerY = platform.y - playerHeight;
                    velocityY = 0;
                    onPlatform = true;
                    isJumping = false;
                }
            });
            
            // Check cloud platform collisions
            cloudPlatforms.forEach(platform => {
                if (
                    playerX + playerWidth > platform.x - distance &&
                    playerX < platform.x - distance + platform.width &&
                    playerY + playerHeight > platform.y &&
                    playerY + playerHeight < platform.y + platform.height / 2 &&
                    velocityY > 0
                ) {
                    playerY = platform.y - playerHeight;
                    velocityY = 0;
                    onPlatform = true;
                    isJumping = false;
                }
            });
            
            // Check pipe collisions
            pipes.forEach(pipe => {
                if (
                    playerX + playerWidth > pipe.x - distance &&
                    playerX < pipe.x - distance + pipe.width &&
                    playerY + playerHeight > pipe.y &&
                    playerY < pipe.y + pipe.height
                ) {
                    // Collision with pipe - push player out
                    if (velocityX > 0) playerX = pipe.x - distance - playerWidth;
                    else if (velocityX < 0) playerX = pipe.x - distance + pipe.width;
                    else if (velocityY > 0) playerY = pipe.y - playerHeight;
                }
            });
            
            // Check ground collision
            if (playerY + playerHeight > gameHeight - 50) {
                playerY = gameHeight - 50 - playerHeight;
                velocityY = 0;
                onPlatform = true;
                isJumping = false;
            }
            
            // Check screen boundaries
            if (playerX < 0) playerX = 0;
            if (playerX + playerWidth > gameWidth) playerX = gameWidth - playerWidth;
            if (playerY < 0) playerY = 0;
            
            // Reset jumping if on platform or ground
            if (onPlatform) isJumping = false;
        }
        
        // Update enemy
        function updateEnemy(enemy) {
            enemy.x += enemy.speed * enemy.direction;
            
            // Change direction if hitting platform edge or pipe
            let shouldTurn = false;
            
            platforms.forEach(platform => {
                if (
                    enemy.x + enemy.width > platform.x &&
                    enemy.x < platform.x + platform.width &&
                    enemy.y + enemy.height > platform.y &&
                    enemy.y < platform.y + platform.height &&
                    (enemy.x + enemy.width > platform.x + platform.width || enemy.x < platform.x)
                ) {
                    shouldTurn = true;
                }
            });
            
            pipes.forEach(pipe => {
                if (
                    enemy.x + enemy.width > pipe.x &&
                    enemy.x < pipe.x + pipe.width &&
                    enemy.y + enemy.height > pipe.y &&
                    enemy.y < pipe.y + pipe.height
                ) {
                    shouldTurn = true;
                }
            });
            
            if (enemy.x <= platforms[0].x || enemy.x + enemy.width >= platforms[0].x + platforms[0].width || shouldTurn) {
                enemy.direction *= -1;
            }
        }
        
        // Check coin collision
        function checkCoinCollision(coin) {
            if (
                playerX + playerWidth > coin.x - distance &&
                playerX < coin.x - distance + coin.width &&
                playerY + playerHeight > coin.y &&
                playerY < coin.y + coin.height &&
                !coin.collected
            ) {
                coin.collected = true;
                score += 100;
                scoreDisplay.textContent = score;
            }
        }
        
        // Check powerup collision
        function checkPowerupCollision(powerup) {
            if (
                playerX + playerWidth > powerup.x - distance &&
                playerX < powerup.x - distance + powerup.width &&
                playerY + playerHeight > powerup.y &&
                playerY < powerup.y + powerup.height &&
                !powerup.collected
            ) {
                powerup.collected = true;
                powerupActive = true;
                powerupType = powerup.type;
                powerupTimer = 300; // 5 seconds at 60fps
            }
        }
        
        // Check enemy collision
        function checkEnemyCollision(enemy) {
            if (
                playerX + playerWidth > enemy.x - distance &&
                playerX < enemy.x - distance + enemy.width &&
                playerY + playerHeight > enemy.y &&
                playerY < enemy.y + enemy.height
            ) {
                // Check if player is jumping on enemy
                if (velocityY > 0 && playerY + playerHeight < enemy.y + enemy.height / 2) {
                    // Jump on enemy
                    velocityY = -jumpStrength / 1.5;
                    enemy.x = -1000; // Move enemy off screen
                    score += 200;
                    scoreDisplay.textContent = score;
                } else if (!powerupActive || powerupType !== 'invincible') {
                    // Hit by enemy
                    loseLife();
                }
            }
        }
        
        // Player loses a life
        function loseLife() {
            lives--;
            livesDisplay.textContent = lives;
            
            // Vibrate on phone if supported
            if (navigator.vibrate) {
                navigator.vibrate(200);
            }
            
            if (lives <= 0) {
                gameOver.style.display = 'block';
                finalScoreDisplay.textContent = score;
                finalDistanceDisplay.textContent = Math.floor(distance) + 'm';
                gameRunning = false;
            } else {
                // Reset player position
                playerX = 100;
                playerY = 400;
                velocityX = 0;
                velocityY = 0;
            }
        }
        
        // Setup device orientation
        function setupOrientation() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', function(event) {
                    // Gamma is the left-to-right tilt in degrees, where right is positive
                    if (event.gamma > 10) {
                        phoneOrientation = 'right';
                    } else if (event.gamma < -10) {
                        phoneOrientation = 'left';
                    } else {
                        phoneOrientation = null;
                    }
                });
            }
        }
        
        // Setup controls
        function setupControls() {
            // Mobile controls - left button
            leftBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                leftKeyActive = true;
            });
            
            leftBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                leftKeyActive = false;
            });
            
            // Mobile controls - right button
            rightBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                rightKeyActive = true;
            });
            
            rightBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                rightKeyActive = false;
            });
            
            // Mobile controls - jump button
            jumpBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (!isJumping) {
                    velocityY = -jumpStrength;
                    isJumping = true;
                }
            });
            
            // Character selection
            characterSelect.addEventListener('change', function() {
                currentCharacter = this.value;
            });
            
            // Start and restart buttons
            startBtn.addEventListener('click', function() {
                instructions.style.display = 'none';
                init();
            });
            
            restartBtn.addEventListener('click', function() {
                gameOver.style.display = 'none';
                init();
            });
            
            // Keyboard support for testing on desktop
            window.addEventListener('keydown', function(e) {
                if (e.key === 'ArrowLeft') leftKeyActive = true;
                else if (e.key === 'ArrowRight') rightKeyActive = true;
                else if (e.key === ' ' || e.key === 'ArrowUp') {
                    if (!isJumping) {
                        velocityY = -jumpStrength;
                        isJumping = true;
                    }
                }
            });
            
            window.addEventListener('keyup', function(e) {
                if (e.key === 'ArrowLeft') leftKeyActive = false;
                else if (e.key === 'ArrowRight') rightKeyActive = false;
            });
        }
        
        // Initialize the game
        setupControls();
        setupOrientation();
    </script>
</body>
</html>